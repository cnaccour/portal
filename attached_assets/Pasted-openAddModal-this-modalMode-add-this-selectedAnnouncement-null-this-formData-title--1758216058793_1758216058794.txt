openAddModal() { this.modalMode = 'add'; this.selectedAnnouncement = null; this.formData = { title: '', content: '', category: 'general', pinned: false, expiration_date: '' }; this.attachments = []; this.showModal = true; // Initialize Quill editor after modal opens setTimeout(() => { this.initQuillEditor(); }, 150); }, openEditModal(announcement) { this.modalMode = 'edit'; this.selectedAnnouncement = announcement; this.formData = { title: announcement.title, content: announcement.content, category: announcement.category, pinned: announcement.pinned, expiration_date: announcement.expiration_date || '' }; this.attachments = announcement.attachments || []; this.showModal = true; // Initialize Quill editor after modal opens setTimeout(() => { this.initQuillEditor(); }, 150); }, closeModal() { // Properly destroy Quill instance before closing if (this.quillEditor) { try { // Clear the editor container const container = document.getElementById('content-editor'); if (container) { container.innerHTML = ''; } this.quillEditor = null; } catch (e) { console.log('Error destroying editor:', e); } } this.showModal = false; this.selectedAnnouncement = null; }, initQuillEditor() { // Destroy any existing editor first if (this.quillEditor) { try { const container = document.getElementById('content-editor'); if (container) { container.innerHTML = ''; } this.quillEditor = null; } catch (e) { console.log('Error cleaning up previous editor:', e); } } // Wait for DOM to be ready const container = document.getElementById('content-editor'); if (container) { // Clear any existing content container.innerHTML = ''; // Create new Quill instance this.quillEditor = new Quill('#content-editor', { theme: 'snow', modules: { toolbar: [ [{ 'header': [1, 2, 3, false] }], ['bold', 'italic', 'underline'], [{ 'list': 'ordered'}, { 'list': 'bullet' }], ['link'], ['clean'] ] } }); // Set initial content (only for edit mode) if (this.modalMode === 'edit' && this.formData.content) { this.quillEditor.root.innerHTML = this.formData.content; } else { // For add mode, ensure content is empty this.quillEditor.root.innerHTML = ''; this.formData.content = ''; } // Update formData when editor content changes this.quillEditor.on('text-change', () => { this.formData.content = this.quillEditor.root.innerHTML; }); } }, async submitForm() { try { // Get content from Quill editor if (this.quillEditor) { this.formData.content = this.quillEditor.root.innerHTML; } const formData = new FormData(); formData.append('csrf_token', '9adfbd6807f6953d0d980318993ae64aef54c26dd4e7de1f4d3983b6f1db3ce7'); formData.append('mode', this.modalMode); formData.append('title', this.formData.title); formData.append('content', this.formData.content); formData.append('category', this.formData.category); formData.append('expiration_date', this.formData.expiration_date); if (this.formData.pinned) { formData.append('pinned', '1'); } if (this.modalMode === 'edit' && this.selectedAnnouncement) { formData.append('announcement_id', this.selectedAnnouncement.id); } const response = await fetch('/api/save-announcement.php', { method: 'POST', body: formData }); const result = await response.json(); if (result.success) { // Show success message and reload page alert(result.message); window.location.reload(); } else { alert('Error: ' + result.error); } } catch (error) { alert('An error occurred: ' + error.message); } }, async deleteAnnouncement(announcementId) { if (!confirm('Are you sure you want to delete this announcement?')) { return; } try { const formData = new FormData(); formData.append('csrf_token', '9adfbd6807f6953d0d980318993ae64aef54c26dd4e7de1f4d3983b6f1db3ce7'); formData.append('announcement_id', announcementId); const response = await fetch('/api/delete-announcement.php', { method: 'POST', body: formData }); const result = await response.json(); if (result.success) { alert(result.message); window.location.reload(); } else { alert('Error: ' + result.error); } } catch (error) { alert('An error occurred: ' + error.message); } }, handleFileSelect(event) { this.handleFiles(event.target.files); }, handleFileDrop(event) { this.handleFiles(event.dataTransfer.files); }, async handleFiles(fileList) { const files = Array.from(fileList); // Validate files for (const file of files) { if (file.size > 10 * 1024 * 1024) { // 10MB alert(`File "${file.name}" is too large. Maximum size is 10MB.`); return; } const allowedTypes = [ 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'image/jpeg', 'image/png', 'image/gif', 'image/webp' ]; if (!allowedTypes.includes(file.type)) { alert(`File "${file.name}" is not a supported type.`); return; } } // If we're editing, upload files immediately if (this.modalMode === 'edit' && this.selectedAnnouncement?.id) { await this.uploadFiles(files, this.selectedAnnouncement.id); } else { // For new announcements, just add to pending list for (const file of files) { this.attachments.push({ name: file.name, size: file.size, type: file.type, pending: true, file: file }); } } }, async uploadFiles(files, announcementId) { this.uploadingFiles = true; try { for (const file of files) { const formData = new FormData(); formData.append('csrf_token', '9adfbd6807f6953d0d980318993ae64aef54c26dd4e7de1f4d3983b6f1db3ce7'); formData.append('announcement_id', announcementId); formData.append('file', file); const response = await fetch('/api/upload-attachment.php', { method: 'POST', body: formData }); const result = await response.json(); if (result.success) { this.attachments.push(result.file); } else { alert(`Error uploading ${file.name}: ${result.error}`); } } } catch (error) { alert('Upload error: ' + error.message); } finally { this.uploadingFiles = false; } }, async removeAttachment(index) { const attachment = this.attachments[index]; if (attachment.pending) { // Just remove from pending list this.attachments.splice(index, 1); return; } if (!confirm('Are you sure you want to delete this attachment?')) { return; } try { const formData = new FormData(); formData.append('csrf_token', '9adfbd6807f6953d0d980318993ae64aef54c26dd4e7de1f4d3983b6f1db3ce7'); formData.append('announcement_id', this.selectedAnnouncement.id); formData.append('filename', attachment.filename); const response = await fetch('/api/delete-attachment.php', { method: 'POST', body: formData }); const result = await response.json(); if (result.success) { this.attachments.splice(index, 1); } else { alert('Error deleting attachment: ' + result.error); } } catch (error) { alert('Error: ' + error.message); } }, formatFileSize(bytes) { if (bytes === 0) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]; } } }